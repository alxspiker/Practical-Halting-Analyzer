import argparse
import sys
from components.paradox_detection import detect_paradox
from components.static_analysis import static_preparation
# --- MODIFIED: Import the new, more powerful Symbolic Prover ---
from components.symbolic_prover import prove_termination
from components.dynamic_tracing import dynamic_tracing
from components.decision_synthesis import decision_synthesis
from components.cross_script_recursion import start_analysis, end_analysis, RecursionCycleDetected
from components.semantic_hashing import get_semantic_hash

def analyze_halting(program: str) -> str:
    """Analyze if a program halts using a multi-phase approach."""
    # Use our most advanced hashing method to prepare for cycle detection.
    program_hash = get_semantic_hash(program)

    try:
        # This will check for both direct (A->A) and polymorphic (A->B->A-like) recursion.
        start_analysis(program_hash)
    except RecursionCycleDetected as e:
        # The cycle detector found a non-halting loop in the analysis itself.
        print(f"Debug: {str(e)}", file=sys.stderr)
        return "does not halt"

    try:
        # Phase 0: Pattern Matching for specific, known paradoxes.
        if detect_paradox(program):
            print("Debug: Detected potential halting paradox", file=sys.stderr)
            return "impossible to determine: detected potential halting paradox"
        
        # Phase 1: Static Preparation (Fastest checks for simple cases)
        static_result = static_preparation(program)
        print(f"Debug: Static result = {static_result}", file=sys.stderr)
        if static_result in ["halts", "does not halt"]:
            return static_result
        
        # --- NEW PHASE 2: The Symbolic Prover ---
        # For cases too complex for the static analyzer but potentially provable
        # without full execution, like loops with clear termination conditions.
        prover_result = prove_termination(program)
        print(f"Debug: Prover result = {prover_result}", file=sys.stderr)
        if prover_result in ["halts", "does not halt"]:
            return prover_result
        
        # Phase 3: Dynamic Tracing (The most powerful and expensive phase)
        dynamic_result = dynamic_tracing(program)
        print(f"Debug: Dynamic result = {dynamic_result}", file=sys.stderr)
        if dynamic_result in ["halts", "does not halt"]:
            return dynamic_result
        
        # Phase 4: Decision Synthesis (Final fallback)
        # Note: We pass prover_result instead of the old symbolic_result.
        final_result = decision_synthesis(static_result, prover_result, dynamic_result, program)
        print(f"Debug: Final result = {final_result}", file=sys.stderr)
        return final_result
        
    except Exception as e:
        print(f"Debug: Exception = {str(e)}", file=sys.stderr)
        return f"impossible to determine: {str(e)}"
    finally:
        # IMPORTANT: Ensure we always pop from the analysis chain.
        end_analysis(program_hash)

if __name__ == "__main__":
    import os
    import sys

    # Note: You may need to create a `cleanup_semantic_paradox.py` script
    # to remove files generated by the test scripts.
    scripts_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'scripts')
    print(f"--- Running Halting Analysis on all scripts in '{scripts_dir}' ---")

    for script_name in sorted(os.listdir(scripts_dir)):
        if script_name.endswith('.py'):
            script_path = os.path.join(scripts_dir, script_name)
            print(f"\n[Analyzing]: {script_name}")
            print("-" * (12 + len(script_name)))
            
            try:
                with open(script_path, 'r') as f:
                    program_code = f.read()
                
                result = analyze_halting(program_code)
                print(f"Result: {result}")
                print("-" * (12 + len(script_name)))

            except Exception as e:
                print(f"Error analyzing {script_name}: {e}", file=sys.stderr)
    
    print("\n--- Analysis Complete ---")